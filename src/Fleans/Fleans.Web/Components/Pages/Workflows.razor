@page "/workflows"
@rendermode InteractiveServer
@using Fleans.Application
@using Fleans.Application.WorkflowFactory
@using Fleans.Domain
@using Fleans.Infrastructure.Bpmn
@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.FluentUI.AspNetCore.Components
@inject WorkflowEngine WorkflowEngine
@inject IBpmnConverter BpmnConverter
@inject ILogger<Workflows> Logger

<PageTitle>Workflows</PageTitle>

<FluentStack Orientation="Orientation.Vertical" Gap="20px">
    <FluentStack Orientation="Orientation.Horizontal" Justify="JustifyContent.SpaceBetween" AlignItems="AlignItems.Center">
        <FluentHeader HSize="HeadingSize.H1">Registered Workflows</FluentHeader>
        
        <FluentStack Orientation="Orientation.Vertical" Gap="20px">
            <FluentInputFile @ref="@myFileUploader" 
                             DragDropZoneVisible="false"
                             Mode="InputFileMode.SaveToTemporaryFolder"
                             Multiple="false"
                             AnchorId="MyUploadButton"
                             MaximumFileSize="@(10 * 1024 * 1024)"
                             Accept=".bpmn,.xml"
                             OnProgressChange="@(e =>
                                               {
                                                   uploadProgressPercent = e.ProgressPercent; 
                                                   uploadProgressTitle = e.ProgressTitle;
                                               })"
                             OnCompleted="@OnFileUploadCompleted" />

            <FluentProgress Min="0" Max="100" Visible="@(uploadProgressPercent > 0)" Value="@uploadProgressPercent" />
            @if (!string.IsNullOrEmpty(uploadProgressTitle))
            {
                <FluentLabel Alignment="HorizontalAlignment.Center">
                    @uploadProgressTitle
                </FluentLabel>
            }

            <FluentButton Id="MyUploadButton" Appearance="Appearance.Accent" Disabled="@isUploading">
                <FluentIcon Value="@(new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size20.ArrowUpload())" />
                <span style="margin-left: 8px;">Select BPMN File</span>
            </FluentButton>

            @if (uploadedFiles.Any())
            {
                <FluentStack Orientation="Orientation.Vertical" Gap="10px">
                    <FluentHeading HSize="HeadingSize.H4">Selected file:</FluentHeading>
                    @foreach (var file in uploadedFiles)
                    {
                        <FluentBodyText>
                            <strong>@file.Name</strong> • 
                            @($"{Decimal.Divide(file.Size, 1024):N} KB") • 
                            @file.ContentType
                            @if (!string.IsNullOrEmpty(file.ErrorMessage))
                            {
                                <FluentMessageBar Intent="MessageIntent.Error">@file.ErrorMessage</FluentMessageBar>
                            }
                        </FluentBodyText>
                    }
                    <FluentButton Appearance="Appearance.Accent" @onclick="HandleFileUpload" Disabled="@isUploading">
                        @if (isUploading)
                        {
                            <FluentProgressRing Size="Size.Small" />
                            <span style="margin-left: 8px;">Uploading...</span>
                        }
                        else
                        {
                            <FluentIcon Value="@(new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size20.ArrowUpload())" />
                            <span style="margin-left: 8px;">Deploy workflow</span>
                        }
                    </FluentButton>
                </FluentStack>
            }

            @if (uploadErrorMessage != null)
            {
                <FluentMessageBar Intent="MessageIntent.Error" Dismissible="true" OnDismissed="@(() => uploadErrorMessage = null)">
                    @uploadErrorMessage
                </FluentMessageBar>
            }
            @if (uploadSuccessMessage != null)
            {
                <FluentMessageBar Intent="MessageIntent.Success" Dismissible="true" OnDismissed="@(() => uploadSuccessMessage = null)">
                    @uploadSuccessMessage
                </FluentMessageBar>
            }
        </FluentStack>
        
    </FluentStack>

    @if (isLoading && (workflowGroups.Count == 0))
    {
        <FluentStack Orientation="Orientation.Vertical" AlignItems="AlignItems.Center" Gap="10px">
            <FluentProgressRing />
            <FluentBodyText>Loading workflows...</FluentBodyText>
        </FluentStack>
    }
    else
    {
        @if (!string.IsNullOrWhiteSpace(loadErrorMessage))
        {
            <FluentMessageBar Intent="MessageIntent.Error" Dismissible="true" OnDismissed="@(() => loadErrorMessage = null)">
                <FluentStack Orientation="Orientation.Horizontal" Gap="10px" AlignItems="AlignItems.Center">
                    <span>@loadErrorMessage</span>
                    <FluentButton Appearance="Appearance.Neutral" @onclick="RefreshWorkflows" Disabled="@isLoading">
                        Retry
                    </FluentButton>
                </FluentStack>
            </FluentMessageBar>
        }

        @if (!string.IsNullOrWhiteSpace(actionErrorMessage))
        {
            <FluentMessageBar Intent="MessageIntent.Error" Dismissible="true" OnDismissed="@(() => actionErrorMessage = null)">
                @actionErrorMessage
            </FluentMessageBar>
        }

        @if (!string.IsNullOrWhiteSpace(actionSuccessMessage))
        {
            <FluentMessageBar Intent="MessageIntent.Success" Dismissible="true" OnDismissed="@(() => actionSuccessMessage = null)">
                @actionSuccessMessage
            </FluentMessageBar>
        }

        @if (workflowGroups.Count == 0)
        {
            <FluentMessageBar Intent="MessageIntent.Info">
                <strong>No workflows found.</strong> Upload a BPMN file to register a workflow.
            </FluentMessageBar>
        }
        else
        {
            <FluentStack Orientation="Orientation.Horizontal" Gap="24px" Style="align-items: flex-start;">
                <FluentStack Orientation="Orientation.Vertical" Gap="12px" Style="min-width: 320px; max-width: 420px; flex: 1;">
                    <FluentTextField Placeholder="Search by process key"
                                     @bind-Value="SearchQuery" />

                    @if (filteredWorkflowGroups.Count == 0)
                    {
                        <FluentMessageBar Intent="MessageIntent.Info">
                            No keys match "@SearchQuery".
                        </FluentMessageBar>
                    }
                    else
                    {
                        <FluentTable Items="@filteredWorkflowGroups">
                            <FluentTableHeader>
                                <FluentTableRow>
                                    <FluentTableHeaderCell>Process Key</FluentTableHeaderCell>
                                    <FluentTableHeaderCell>Latest Version</FluentTableHeaderCell>
                                    <FluentTableHeaderCell>Versions</FluentTableHeaderCell>
                                    <FluentTableHeaderCell>Actions</FluentTableHeaderCell>
                                </FluentTableRow>
                            </FluentTableHeader>
                            <FluentTableBody>
                                @foreach (var group in filteredWorkflowGroups)
                                {
                                    var isSelected = selectedGroup?.ProcessDefinitionKey == group.ProcessDefinitionKey;
                                    <FluentTableRow @onclick="() => SelectGroup(group)" Style="@GetRowStyle(isSelected)">
                                        <FluentTableCell>
                                            <strong>@group.ProcessDefinitionKey</strong>
                                        </FluentTableCell>
                                        <FluentTableCell>
                                            <FluentBadge Color="Color.Accent">v@group.LatestVersion</FluentBadge>
                                        </FluentTableCell>
                                        <FluentTableCell>
                                            <FluentBadge Color="Color.Neutral">@group.TotalVersions</FluentBadge>
                                        </FluentTableCell>
                                        <FluentTableCell>
                                            <FluentButton Appearance="Appearance.Stealth"
                                                          @onclick="() => StartLatestWorkflow(group.ProcessDefinitionKey)"
                                                          Disabled="@isStarting">
                                                @if (isStarting && startingWorkflowKey == group.ProcessDefinitionKey)
                                                {
                                                    <FluentProgressRing Size="Size.Small" />
                                                    <span style="margin-left: 8px;">Starting latest...</span>
                                                }
                                                else
                                                {
                                                    <FluentIcon Value="@(new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size20.Play())" />
                                                    <span style="margin-left: 8px;">Start (latest)</span>
                                                }
                                            </FluentButton>
                                        </FluentTableCell>
                                    </FluentTableRow>
                                }
                            </FluentTableBody>
                        </FluentTable>
                    }
                </FluentStack>

                <FluentStack Orientation="Orientation.Vertical" Gap="12px" Style="flex: 2;">
                    <FluentStack Orientation="Orientation.Horizontal" AlignItems="AlignItems.Center" Justify="JustifyContent.SpaceBetween">
                        <FluentHeading HSize="HeadingSize.H3">
                            @if (selectedGroup == null)
                            {
                                <span>Versions</span>
                            }
                            else
                            {
                                <span>Versions for @selectedGroup.ProcessDefinitionKey</span>
                            }
                        </FluentHeading>

                        <FluentButton Appearance="Appearance.Accent"
                                      @onclick="StartSelectedVersion"
                                      Disabled="@(isStarting || string.IsNullOrWhiteSpace(selectedProcessDefinitionId))">
                            @if (isStarting && startingProcessDefinitionId == selectedProcessDefinitionId)
                            {
                                <FluentProgressRing Size="Size.Small" />
                                <span style="margin-left: 8px;">Starting...</span>
                            }
                            else
                            {
                                <FluentIcon Value="@(new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size20.Play())" />
                                <span style="margin-left: 8px;">Start selected version</span>
                            }
                        </FluentButton>
                    </FluentStack>

                    @if (filteredWorkflowGroups.Count == 0)
                    {
                        <FluentMessageBar Intent="MessageIntent.Info">
                            No keys match "@SearchQuery".
                        </FluentMessageBar>
                    }
                    else if (selectedGroup == null)
                    {
                        <FluentMessageBar Intent="MessageIntent.Info">
                            Select a process key to view its versions.
                        </FluentMessageBar>
                    }
                    else if (selectedGroup.Versions.Count == 0)
                    {
                        <FluentMessageBar Intent="MessageIntent.Info">
                            No versions found for this key.
                        </FluentMessageBar>
                    }
                    else
                    {
                        <FluentTable Items="@selectedGroup.Versions">
                            <FluentTableHeader>
                                <FluentTableRow>
                                    <FluentTableHeaderCell>Version</FluentTableHeaderCell>
                                    <FluentTableHeaderCell>Deployed at (UTC)</FluentTableHeaderCell>
                                    <FluentTableHeaderCell>Process definition id</FluentTableHeaderCell>
                                </FluentTableRow>
                            </FluentTableHeader>
                            <FluentTableBody>
                                @foreach (var version in selectedGroup.Versions)
                                {
                                    var isSelected = selectedProcessDefinitionId == version.ProcessDefinitionId;
                                    <FluentTableRow @onclick="() => SelectVersion(version)" Style="@GetRowStyle(isSelected)">
                                        <FluentTableCell>
                                            <FluentBadge Color="Color.Accent">v@version.Version</FluentBadge>
                                        </FluentTableCell>
                                        <FluentTableCell>
                                            @version.DeployedAt.ToUniversalTime().ToString("u")
                                        </FluentTableCell>
                                        <FluentTableCell>
                                            <FluentBodyText>@version.ProcessDefinitionId</FluentBodyText>
                                        </FluentTableCell>
                                    </FluentTableRow>
                                }
                            </FluentTableBody>
                        </FluentTable>
                    }
                </FluentStack>
            </FluentStack>

            <FluentButton Appearance="Appearance.Neutral" @onclick="RefreshWorkflows" Disabled="@isLoading">
                <FluentIcon Value="@(new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size20.ArrowSync())" />
                Refresh
            </FluentButton>
        }
    }
</FluentStack>



@code {
    private sealed class WorkflowGroupVm
    {
        public required string ProcessDefinitionKey { get; init; }
        public required int LatestVersion { get; init; }
        public required int TotalVersions { get; init; }
        public required List<ProcessDefinitionSummary> Versions { get; init; }
    }

    private List<WorkflowGroupVm> workflowGroups = new();
    private List<WorkflowGroupVm> filteredWorkflowGroups = new();
    private WorkflowGroupVm? selectedGroup;
    private bool isLoading = true;
    private string? loadErrorMessage;
    private string? actionErrorMessage;
    private string? actionSuccessMessage;
    private bool isStarting = false;
    private string? startingWorkflowKey;
    private string? startingProcessDefinitionId;
    private string? selectedProcessDefinitionId;
    private string searchQuery = string.Empty;
    private bool showUploadModal = false;
    private bool isUploading = false;
    private FluentInputFile? myFileUploader = default!;
    private int? uploadProgressPercent;
    private string? uploadProgressTitle;
    private FluentInputFileEventArgs[] uploadedFiles = Array.Empty<FluentInputFileEventArgs>();
    private string? uploadErrorMessage;
    private string? uploadSuccessMessage;

    private string SearchQuery
    {
        get => searchQuery;
        set
        {
            if (searchQuery == value)
            {
                return;
            }

            searchQuery = value;
            ApplyFilter();
        }
    }

    protected override async Task OnInitializedAsync()
    {
        await LoadWorkflows();
    }

    private async Task LoadWorkflows()
    {
        try
        {
            isLoading = true;
            loadErrorMessage = null;

            var definitions = await WorkflowEngine.GetAllProcessDefinitions();

            workflowGroups = definitions
                .GroupBy(d => d.ProcessDefinitionKey, StringComparer.Ordinal)
                .Select(g =>
                {
                    var ordered = g.OrderByDescending(d => d.Version).ToList();
                    var latest = ordered[0];
                    return new WorkflowGroupVm
                    {
                        ProcessDefinitionKey = g.Key,
                        LatestVersion = latest.Version,
                        TotalVersions = ordered.Count,
                        Versions = ordered
                    };
                })
                .OrderBy(g => g.ProcessDefinitionKey, StringComparer.Ordinal)
                .ToList();

            ApplyFilter();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading workflows");
            loadErrorMessage = "Unable to reach workflow engine. Try again.";
            if (workflowGroups.Count == 0)
            {
                filteredWorkflowGroups.Clear();
                selectedGroup = null;
                selectedProcessDefinitionId = null;
            }
        }
        finally
        {
            isLoading = false;
        }
    }

    private async Task RefreshWorkflows()
    {
        await LoadWorkflows();
    }

    private void ApplyFilter()
    {
        filteredWorkflowGroups = workflowGroups
            .Where(g => string.IsNullOrWhiteSpace(SearchQuery)
                        || g.ProcessDefinitionKey.Contains(SearchQuery, StringComparison.OrdinalIgnoreCase))
            .OrderBy(g => g.ProcessDefinitionKey, StringComparer.Ordinal)
            .ToList();

        if (filteredWorkflowGroups.Count == 0)
        {
            selectedGroup = null;
            selectedProcessDefinitionId = null;
            return;
        }

        if (selectedGroup == null || filteredWorkflowGroups.All(g => g.ProcessDefinitionKey != selectedGroup.ProcessDefinitionKey))
        {
            selectedGroup = filteredWorkflowGroups[0];
            selectedProcessDefinitionId = null;
            return;
        }

        selectedGroup = filteredWorkflowGroups.First(g => g.ProcessDefinitionKey == selectedGroup.ProcessDefinitionKey);
        if (!string.IsNullOrWhiteSpace(selectedProcessDefinitionId)
            && selectedGroup.Versions.All(v => v.ProcessDefinitionId != selectedProcessDefinitionId))
        {
            selectedProcessDefinitionId = null;
        }
    }

    private void SelectGroup(WorkflowGroupVm group)
    {
        if (selectedGroup?.ProcessDefinitionKey == group.ProcessDefinitionKey)
        {
            return;
        }

        selectedGroup = group;
        selectedProcessDefinitionId = null;
    }

    private void SelectVersion(ProcessDefinitionSummary version)
    {
        selectedProcessDefinitionId = version.ProcessDefinitionId;
    }

    private static string GetRowStyle(bool isSelected) =>
        isSelected
            ? "cursor: pointer; background-color: var(--neutral-layer-2);"
            : "cursor: pointer;";

    private async Task StartLatestWorkflow(string processDefinitionKey)
    {
        try
        {
            isStarting = true;
            startingWorkflowKey = processDefinitionKey;
            startingProcessDefinitionId = null;
            actionErrorMessage = null;
            actionSuccessMessage = null;

            var instanceId = await WorkflowEngine.StartWorkflow(processDefinitionKey);
            Logger.LogInformation("Workflow {ProcessDefinitionKey} (latest) started successfully with instanceId {WorkflowInstanceId}", processDefinitionKey, instanceId);
            actionSuccessMessage = $"Started '{processDefinitionKey}' (latest). Instance: {instanceId}.";
        }
        catch (KeyNotFoundException ex)
        {
            Logger.LogWarning("Failed to start workflow {ProcessDefinitionKey}: {Error}", processDefinitionKey, ex.Message);
            actionErrorMessage = $"Failed to start workflow: {ex.Message}";
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error starting workflow {ProcessDefinitionKey}", processDefinitionKey);
            actionErrorMessage = $"Failed to start workflow: {ex.Message}";
        }
        finally
        {
            isStarting = false;
            startingWorkflowKey = null;
        }
    }

    private async Task StartSelectedVersion()
    {
        if (string.IsNullOrWhiteSpace(selectedProcessDefinitionId))
        {
            actionSuccessMessage = null;
            actionErrorMessage = "Please select a version to start.";
            return;
        }

        try
        {
            isStarting = true;
            startingProcessDefinitionId = selectedProcessDefinitionId;
            startingWorkflowKey = null;
            actionErrorMessage = null;
            actionSuccessMessage = null;

            var instanceId = await WorkflowEngine.StartWorkflowByProcessDefinitionId(selectedProcessDefinitionId);
            Logger.LogInformation("Process definition {ProcessDefinitionId} started successfully with instanceId {WorkflowInstanceId}", selectedProcessDefinitionId, instanceId);
            actionSuccessMessage = $"Started '{selectedProcessDefinitionId}'. Instance: {instanceId}.";
        }
        catch (KeyNotFoundException ex)
        {
            Logger.LogWarning("Failed to start process definition {ProcessDefinitionId}: {Error}", selectedProcessDefinitionId, ex.Message);
            actionErrorMessage = $"Failed to start workflow: {ex.Message}";
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error starting process definition {ProcessDefinitionId}", selectedProcessDefinitionId);
            actionErrorMessage = $"Failed to start workflow: {ex.Message}";
        }
        finally
        {
            isStarting = false;
            startingProcessDefinitionId = null;
        }
    }

    private void ShowUploadDialog()
    {
        showUploadModal = true;
        uploadErrorMessage = null;
        uploadSuccessMessage = null;
        uploadedFiles = Array.Empty<FluentInputFileEventArgs>();
        uploadProgressPercent = null;
        uploadProgressTitle = null;
        
        StateHasChanged();
    }

    private void HideUploadDialog()
    {
        showUploadModal = false;
        uploadErrorMessage = null;
        uploadSuccessMessage = null;
        uploadedFiles = Array.Empty<FluentInputFileEventArgs>();
        uploadProgressPercent = null;
        uploadProgressTitle = null;
        
        // Clean up temporary files
        foreach (var file in uploadedFiles)
        {
            file.LocalFile?.Delete();
        }
    }

    private void OnFileUploadCompleted(IEnumerable<FluentInputFileEventArgs> files)
    {
        uploadedFiles = files.ToArray();
        uploadProgressPercent = myFileUploader?.ProgressPercent;
        uploadProgressTitle = myFileUploader?.ProgressTitle;
        
        // Check for errors in uploaded files
        var errorFile = uploadedFiles.FirstOrDefault(f => !string.IsNullOrEmpty(f.ErrorMessage));
        if (errorFile != null)
        {
            uploadErrorMessage = errorFile.ErrorMessage;
        }
    }

    private async Task HandleFileUpload()
    {
        if (!uploadedFiles.Any())
        {
            uploadErrorMessage = "Please select a file to upload";
            return;
        }

        var file = uploadedFiles.First();
        
        if (!string.IsNullOrEmpty(file.ErrorMessage))
        {
            uploadErrorMessage = file.ErrorMessage;
            return;
        }

        try
        {
            isUploading = true;
            uploadErrorMessage = null;
            uploadSuccessMessage = null;

            // Validate file extension
            if (!file.Name.EndsWith(".bpmn", StringComparison.OrdinalIgnoreCase) &&
                !file.Name.EndsWith(".xml", StringComparison.OrdinalIgnoreCase))
            {
                uploadErrorMessage = "File must be a BPMN (.bpmn) or XML (.xml) file";
                return;
            }

            // Read file from temporary location
            if (file.LocalFile == null || !file.LocalFile.Exists)
            {
                uploadErrorMessage = "File not found. Please select the file again.";
                return;
            }

            using var fileStream = file.LocalFile.OpenRead();
            var workflow = await BpmnConverter.ConvertFromXmlAsync(fileStream);
            
            // Deploy workflow (Camunda-like: every deploy creates a new version per BPMN process id)
            var deployed = await WorkflowEngine.DeployWorkflow(workflow);
            
            uploadSuccessMessage = $"BPMN deployed successfully (Key: {deployed.ProcessDefinitionKey}, Version: v{deployed.Version}, Activities: {deployed.ActivitiesCount}, Flows: {deployed.SequenceFlowsCount})";
            
            // Refresh the workflow list after successful upload
            await Task.Delay(1000); // Small delay to show success message
            await LoadWorkflows();
            HideUploadDialog();
        }
        catch (InvalidOperationException ex)
        {
            Logger.LogError(ex, "Invalid BPMN file");
            uploadErrorMessage = $"Invalid BPMN file: {ex.Message}";
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error uploading BPMN file");
            uploadErrorMessage = $"Failed to upload file: {ex.Message}";
        }
        finally
        {
            isUploading = false;
        }
    }
}
