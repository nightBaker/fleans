@page "/workflows"
@rendermode InteractiveServer
@using Fleans.Application
@using Fleans.Domain
@using Microsoft.FluentUI.AspNetCore.Components
@inject WorkflowEngine WorkflowEngine
@inject ILogger<Workflows> Logger

<PageTitle>Workflows</PageTitle>

<FluentStack Orientation="Orientation.Vertical" Gap="20px">
    <FluentStack Orientation="Orientation.Horizontal" Justify="JustifyContent.SpaceBetween" AlignItems="AlignItems.Center">
        <FluentHeader HSize="HeadingSize.H1">Registered Workflows</FluentHeader>
        <WorkflowUploadPanel OnWorkflowDeployed="HandleWorkflowDeployed" />
    </FluentStack>

    @if (isLoading && (workflowGroups.Count == 0))
    {
        <FluentStack Orientation="Orientation.Vertical" AlignItems="AlignItems.Center" Gap="10px">
            <FluentProgressRing />
            <FluentBodyText>Loading workflows...</FluentBodyText>
        </FluentStack>
    }
    else
    {
        @if (!string.IsNullOrWhiteSpace(loadErrorMessage))
        {
            <FluentMessageBar Intent="MessageIntent.Error" Dismissible="true" OnDismissed="@(() => loadErrorMessage = null)">
                <FluentStack Orientation="Orientation.Horizontal" Gap="10px" AlignItems="AlignItems.Center">
                    <span>@loadErrorMessage</span>
                    <FluentButton Appearance="Appearance.Neutral" @onclick="RefreshWorkflows" Disabled="@isLoading">
                        Retry
                    </FluentButton>
                </FluentStack>
            </FluentMessageBar>
        }

        @if (!string.IsNullOrWhiteSpace(actionErrorMessage))
        {
            <FluentMessageBar Intent="MessageIntent.Error" Dismissible="true" OnDismissed="@(() => actionErrorMessage = null)">
                @actionErrorMessage
            </FluentMessageBar>
        }

        @if (!string.IsNullOrWhiteSpace(actionSuccessMessage))
        {
            <FluentMessageBar Intent="MessageIntent.Success" Dismissible="true" OnDismissed="@(() => actionSuccessMessage = null)">
                @actionSuccessMessage
            </FluentMessageBar>
        }

        @if (workflowGroups.Count == 0)
        {
            <FluentMessageBar Intent="MessageIntent.Info">
                <strong>No workflows found.</strong> Upload a BPMN file to register a workflow.
            </FluentMessageBar>
        }
        else
        {
            <FluentStack Orientation="Orientation.Horizontal" Gap="24px" Style="align-items: flex-start;">
                <WorkflowKeysPanel Groups="filteredWorkflowGroups"
                                   SelectedGroup="selectedGroup"
                                   @bind-SearchQuery="SearchQuery"
                                   OnSelectGroup="SelectGroup"
                                   OnStartLatest="StartLatestWorkflow"
                                   IsStarting="isStarting"
                                   StartingWorkflowKey="startingWorkflowKey" />

                <WorkflowVersionsPanel SelectedGroup="selectedGroup"
                                       HasFilteredKeys="filteredWorkflowGroups.Count > 0"
                                       SearchQuery="SearchQuery"
                                       SelectedProcessDefinitionId="selectedProcessDefinitionId"
                                       OnSelectVersion="SelectVersion"
                                       OnStartSelected="StartSelectedVersion"
                                       IsStarting="isStarting"
                                       StartingProcessDefinitionId="startingProcessDefinitionId" />
            </FluentStack>

            <FluentButton Appearance="Appearance.Neutral" @onclick="RefreshWorkflows" Disabled="@isLoading">
                <FluentIcon Value="@(new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size20.ArrowSync())" />
                Refresh
            </FluentButton>
        }
    }
</FluentStack>



@code {
    private List<WorkflowGroupVm> workflowGroups = new();
    private List<WorkflowGroupVm> filteredWorkflowGroups = new();
    private WorkflowGroupVm? selectedGroup;
    private bool isLoading = true;
    private string? loadErrorMessage;
    private string? actionErrorMessage;
    private string? actionSuccessMessage;
    private bool isStarting = false;
    private string? startingWorkflowKey;
    private string? startingProcessDefinitionId;
    private string? selectedProcessDefinitionId;
    private string searchQuery = string.Empty;

    private string SearchQuery
    {
        get => searchQuery;
        set
        {
            if (searchQuery == value)
            {
                return;
            }

            searchQuery = value;
            ApplyFilter();
        }
    }

    protected override async Task OnInitializedAsync()
    {
        await LoadWorkflows();
    }

    private async Task LoadWorkflows()
    {
        try
        {
            isLoading = true;
            loadErrorMessage = null;

            var definitions = await WorkflowEngine.GetAllProcessDefinitions();

            workflowGroups = definitions
                .GroupBy(d => d.ProcessDefinitionKey, StringComparer.Ordinal)
                .Select(g =>
                {
                    var ordered = g.OrderByDescending(d => d.Version).ToList();
                    var latest = ordered[0];
                    return new WorkflowGroupVm
                    {
                        ProcessDefinitionKey = g.Key,
                        LatestVersion = latest.Version,
                        TotalVersions = ordered.Count,
                        Versions = ordered
                    };
                })
                .OrderBy(g => g.ProcessDefinitionKey, StringComparer.Ordinal)
                .ToList();

            ApplyFilter();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading workflows");
            loadErrorMessage = "Unable to reach workflow engine. Try again.";
            if (workflowGroups.Count == 0)
            {
                filteredWorkflowGroups.Clear();
                selectedGroup = null;
                selectedProcessDefinitionId = null;
            }
        }
        finally
        {
            isLoading = false;
        }
    }

    private async Task RefreshWorkflows()
    {
        await LoadWorkflows();
    }

    private async Task HandleWorkflowDeployed()
    {
        await LoadWorkflows();
    }

    private void ApplyFilter()
    {
        filteredWorkflowGroups = workflowGroups
            .Where(g => string.IsNullOrWhiteSpace(SearchQuery)
                        || g.ProcessDefinitionKey.Contains(SearchQuery, StringComparison.OrdinalIgnoreCase))
            .OrderBy(g => g.ProcessDefinitionKey, StringComparer.Ordinal)
            .ToList();

        if (filteredWorkflowGroups.Count == 0)
        {
            selectedGroup = null;
            selectedProcessDefinitionId = null;
            return;
        }

        if (selectedGroup == null || filteredWorkflowGroups.All(g => g.ProcessDefinitionKey != selectedGroup.ProcessDefinitionKey))
        {
            selectedGroup = filteredWorkflowGroups[0];
            selectedProcessDefinitionId = null;
            return;
        }

        selectedGroup = filteredWorkflowGroups.First(g => g.ProcessDefinitionKey == selectedGroup.ProcessDefinitionKey);
        if (!string.IsNullOrWhiteSpace(selectedProcessDefinitionId)
            && selectedGroup.Versions.All(v => v.ProcessDefinitionId != selectedProcessDefinitionId))
        {
            selectedProcessDefinitionId = null;
        }
    }

    private void SelectGroup(WorkflowGroupVm group)
    {
        if (selectedGroup?.ProcessDefinitionKey == group.ProcessDefinitionKey)
        {
            return;
        }

        selectedGroup = group;
        selectedProcessDefinitionId = null;
    }

    private void SelectVersion(ProcessDefinitionSummary version)
    {
        selectedProcessDefinitionId = version.ProcessDefinitionId;
    }

    private async Task StartLatestWorkflow(string processDefinitionKey)
    {
        try
        {
            isStarting = true;
            startingWorkflowKey = processDefinitionKey;
            startingProcessDefinitionId = null;
            actionErrorMessage = null;
            actionSuccessMessage = null;

            var instanceId = await WorkflowEngine.StartWorkflow(processDefinitionKey);
            Logger.LogInformation("Workflow {ProcessDefinitionKey} (latest) started successfully with instanceId {WorkflowInstanceId}", processDefinitionKey, instanceId);
            actionSuccessMessage = $"Started '{processDefinitionKey}' (latest). Instance: {instanceId}.";
        }
        catch (KeyNotFoundException ex)
        {
            Logger.LogWarning("Failed to start workflow {ProcessDefinitionKey}: {Error}", processDefinitionKey, ex.Message);
            actionErrorMessage = $"Failed to start workflow: {ex.Message}";
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error starting workflow {ProcessDefinitionKey}", processDefinitionKey);
            actionErrorMessage = $"Failed to start workflow: {ex.Message}";
        }
        finally
        {
            isStarting = false;
            startingWorkflowKey = null;
        }
    }

    private async Task StartSelectedVersion()
    {
        if (string.IsNullOrWhiteSpace(selectedProcessDefinitionId))
        {
            actionSuccessMessage = null;
            actionErrorMessage = "Please select a version to start.";
            return;
        }

        try
        {
            isStarting = true;
            startingProcessDefinitionId = selectedProcessDefinitionId;
            startingWorkflowKey = null;
            actionErrorMessage = null;
            actionSuccessMessage = null;

            var instanceId = await WorkflowEngine.StartWorkflowByProcessDefinitionId(selectedProcessDefinitionId);
            Logger.LogInformation("Process definition {ProcessDefinitionId} started successfully with instanceId {WorkflowInstanceId}", selectedProcessDefinitionId, instanceId);
            actionSuccessMessage = $"Started '{selectedProcessDefinitionId}'. Instance: {instanceId}.";
        }
        catch (KeyNotFoundException ex)
        {
            Logger.LogWarning("Failed to start process definition {ProcessDefinitionId}: {Error}", selectedProcessDefinitionId, ex.Message);
            actionErrorMessage = $"Failed to start workflow: {ex.Message}";
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error starting process definition {ProcessDefinitionId}", selectedProcessDefinitionId);
            actionErrorMessage = $"Failed to start workflow: {ex.Message}";
        }
        finally
        {
            isStarting = false;
            startingProcessDefinitionId = null;
        }
    }

}
