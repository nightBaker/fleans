@using Microsoft.FluentUI.AspNetCore.Components
@inject IJSRuntime JS

<div class="properties-panel">
    <div class="properties-panel-header">
        <FluentLabel Typo="Typography.Body" Weight="FontWeight.Bold">@GetTypeLabel()</FluentLabel>
    </div>

    <div class="properties-panel-body">
        <FluentStack Orientation="Orientation.Vertical" Gap="12px">
            @if (!ReadOnly && GetReplaceOptions() is { Count: > 1 } options)
            {
                <div>
                    <FluentLabel Typo="Typography.Body" Weight="FontWeight.Bold">Type</FluentLabel>
                    <FluentSelect TOption="string" Value="@Element.Type" @onchange="OnTypeChange" Style="width: 100%;">
                        @foreach (var opt in options)
                        {
                            <FluentOption TOption="string" Value="@opt.Key" Selected="@(opt.Key == Element.Type)">@opt.Value</FluentOption>
                        }
                    </FluentSelect>
                </div>
            }

            <div>
                <FluentLabel Typo="Typography.Body" Weight="FontWeight.Bold">ID</FluentLabel>
                <FluentTextField Value="@elementId" @oninput="OnIdInput" @onchange="OnIdChange" Disabled="@ReadOnly" Style="width: 100%;" />
            </div>

            <div>
                <FluentLabel Typo="Typography.Body" Weight="FontWeight.Bold">Name</FluentLabel>
                <FluentTextField Value="@name" @oninput="OnNameInput" @onchange="OnNameChange" Disabled="@ReadOnly" Style="width: 100%;" />
            </div>

            @if (Element.Type == "bpmn:ScriptTask")
            {
                <div>
                    <FluentLabel Typo="Typography.Body" Weight="FontWeight.Bold">Script Format</FluentLabel>
                    <FluentTextField Value="@scriptFormat" @oninput="OnScriptFormatInput" @onchange="OnScriptFormatChange"
                                     Disabled="@ReadOnly" Placeholder="e.g. javascript" Style="width: 100%;" />
                </div>

                <div>
                    <FluentLabel Typo="Typography.Body" Weight="FontWeight.Bold">Script</FluentLabel>
                    <FluentTextArea Value="@script" @oninput="OnScriptInput" @onchange="OnScriptChange"
                                    Disabled="@ReadOnly" Rows="8" Resize="TextAreaResize.Vertical" Style="width: 100%;" />
                </div>
            }

            @if (Element.Type == "bpmn:CallActivity")
            {
                <div>
                    <FluentLabel Typo="Typography.Body" Weight="FontWeight.Bold">Called Process Key</FluentLabel>
                    <FluentTextField Value="@calledElement" @oninput="OnCalledElementInput" @onchange="OnCalledElementChange"
                                     Disabled="@ReadOnly" Placeholder="e.g. child-process-1" Style="width: 100%;" />
                </div>

                <div>
                    <FluentCheckbox Value="@propagateAllParentVariables" @onchange="OnPropagateParentChange"
                                    Disabled="@ReadOnly" Label="Propagate all parent variables" />
                </div>

                <div>
                    <FluentCheckbox Value="@propagateAllChildVariables" @onchange="OnPropagateChildChange"
                                    Disabled="@ReadOnly" Label="Propagate all child variables" />
                </div>

                <div>
                    <FluentLabel Typo="Typography.Body" Weight="FontWeight.Bold">Input Mappings</FluentLabel>
                    @for (var i = 0; i < Element.InputMappings.Count; i++)
                    {
                        var index = i;
                        <FluentStack Orientation="Orientation.Horizontal" Gap="4px" Style="align-items: end;">
                            <FluentTextField Value="@Element.InputMappings[index].Source"
                                             @onchange="@(e => OnMappingSourceChange(e, "input", index))"
                                             Disabled="@ReadOnly" Placeholder="Source" Style="flex: 1;" />
                            <FluentTextField Value="@Element.InputMappings[index].Target"
                                             @onchange="@(e => OnMappingTargetChange(e, "input", index))"
                                             Disabled="@ReadOnly" Placeholder="Target" Style="flex: 1;" />
                            @if (!ReadOnly)
                            {
                                <FluentButton Appearance="Appearance.Outline" OnClick="@(() => RemoveMapping("input", index))">Remove</FluentButton>
                            }
                        </FluentStack>
                    }
                    @if (!ReadOnly)
                    {
                        <FluentButton Appearance="Appearance.Outline" OnClick="@(() => AddMapping("input"))">Add Input Mapping</FluentButton>
                    }
                </div>

                <div>
                    <FluentLabel Typo="Typography.Body" Weight="FontWeight.Bold">Output Mappings</FluentLabel>
                    @for (var i = 0; i < Element.OutputMappings.Count; i++)
                    {
                        var index = i;
                        <FluentStack Orientation="Orientation.Horizontal" Gap="4px" Style="align-items: end;">
                            <FluentTextField Value="@Element.OutputMappings[index].Source"
                                             @onchange="@(e => OnMappingSourceChange(e, "output", index))"
                                             Disabled="@ReadOnly" Placeholder="Source" Style="flex: 1;" />
                            <FluentTextField Value="@Element.OutputMappings[index].Target"
                                             @onchange="@(e => OnMappingTargetChange(e, "output", index))"
                                             Disabled="@ReadOnly" Placeholder="Target" Style="flex: 1;" />
                            @if (!ReadOnly)
                            {
                                <FluentButton Appearance="Appearance.Outline" OnClick="@(() => RemoveMapping("output", index))">Remove</FluentButton>
                            }
                        </FluentStack>
                    }
                    @if (!ReadOnly)
                    {
                        <FluentButton Appearance="Appearance.Outline" OnClick="@(() => AddMapping("output"))">Add Output Mapping</FluentButton>
                    }
                </div>
            }

            @if (Element.Type == "bpmn:SequenceFlow")
            {
                <div>
                    <FluentLabel Typo="Typography.Body" Weight="FontWeight.Bold">Condition Expression</FluentLabel>
                    <FluentTextArea Value="@conditionExpression" @oninput="OnConditionInput" @onchange="OnConditionChange"
                                    Disabled="@ReadOnly" Rows="3" Resize="TextAreaResize.Vertical"
                                    Placeholder="e.g. ${amount > 100}" Style="width: 100%;" />
                </div>
            }
        </FluentStack>
    </div>
</div>

@code {
    [Parameter, EditorRequired] public BpmnElementData Element { get; set; } = default!;
    [Parameter] public bool ReadOnly { get; set; }
    [Parameter] public EventCallback<BpmnElementData> OnElementReplaced { get; set; }

    private string elementId = "";
    private string name = "";
    private string scriptFormat = "";
    private string script = "";
    private string conditionExpression = "";
    private string calledElement = "";
    private bool propagateAllParentVariables = true;
    private bool propagateAllChildVariables = true;

    private static readonly Dictionary<string, string> TaskTypes = new()
    {
        ["bpmn:Task"] = "Task",
        ["bpmn:UserTask"] = "User Task",
        ["bpmn:ServiceTask"] = "Service Task",
        ["bpmn:ScriptTask"] = "Script Task",
        ["bpmn:CallActivity"] = "Call Activity",
    };

    private static readonly Dictionary<string, string> GatewayTypes = new()
    {
        ["bpmn:ExclusiveGateway"] = "Exclusive Gateway",
        ["bpmn:ParallelGateway"] = "Parallel Gateway",
    };

    private static readonly Dictionary<string, string> EventTypes = new()
    {
        ["bpmn:StartEvent"] = "Start Event",
        ["bpmn:EndEvent"] = "End Event",
        ["bpmn:IntermediateThrowEvent"] = "Intermediate Throw Event",
        ["bpmn:IntermediateCatchEvent"] = "Intermediate Catch Event",
    };

    protected override void OnParametersSet()
    {
        elementId = Element.Id;
        name = Element.Name;
        scriptFormat = Element.ScriptFormat;
        script = Element.Script;
        conditionExpression = Element.ConditionExpression;
        calledElement = Element.CalledElement;
        propagateAllParentVariables = Element.PropagateAllParentVariables;
        propagateAllChildVariables = Element.PropagateAllChildVariables;
    }

    private Dictionary<string, string>? GetReplaceOptions()
    {
        if (TaskTypes.ContainsKey(Element.Type)) return TaskTypes;
        if (GatewayTypes.ContainsKey(Element.Type)) return GatewayTypes;
        if (EventTypes.ContainsKey(Element.Type)) return EventTypes;
        return null;
    }

    private async Task OnTypeChange(ChangeEventArgs e)
    {
        var newType = e.Value?.ToString();
        if (string.IsNullOrEmpty(newType) || newType == Element.Type) return;

        var result = await JS.InvokeAsync<BpmnElementData>("bpmnEditor.replaceElement", Element.Id, newType);
        if (result != null)
        {
            await OnElementReplaced.InvokeAsync(result);
        }
    }

    private void OnIdInput(ChangeEventArgs e) => elementId = e.Value?.ToString() ?? "";
    private async Task OnIdChange(ChangeEventArgs e)
    {
        var newId = e.Value?.ToString() ?? "";
        if (string.IsNullOrWhiteSpace(newId) || newId == Element.Id) return;

        var result = await JS.InvokeAsync<BpmnElementData>("bpmnEditor.updateElementId", Element.Id, newId);
        if (result != null)
        {
            await OnElementReplaced.InvokeAsync(result);
        }
    }

    private void OnNameInput(ChangeEventArgs e) => name = e.Value?.ToString() ?? "";
    private async Task OnNameChange(ChangeEventArgs e)
    {
        name = e.Value?.ToString() ?? "";
        await JS.InvokeVoidAsync("bpmnEditor.updateElementProperty", Element.Id, "name", name);
    }

    private void OnScriptFormatInput(ChangeEventArgs e) => scriptFormat = e.Value?.ToString() ?? "";
    private async Task OnScriptFormatChange(ChangeEventArgs e)
    {
        scriptFormat = e.Value?.ToString() ?? "";
        await JS.InvokeVoidAsync("bpmnEditor.updateElementProperty", Element.Id, "scriptFormat", scriptFormat);
    }

    private void OnScriptInput(ChangeEventArgs e) => script = e.Value?.ToString() ?? "";
    private async Task OnScriptChange(ChangeEventArgs e)
    {
        script = e.Value?.ToString() ?? "";
        await JS.InvokeVoidAsync("bpmnEditor.updateElementProperty", Element.Id, "script", script);
    }

    private void OnConditionInput(ChangeEventArgs e) => conditionExpression = e.Value?.ToString() ?? "";
    private async Task OnConditionChange(ChangeEventArgs e)
    {
        conditionExpression = e.Value?.ToString() ?? "";
        await JS.InvokeVoidAsync("bpmnEditor.updateElementProperty", Element.Id, "conditionExpression", conditionExpression);
    }

    private void OnCalledElementInput(ChangeEventArgs e) => calledElement = e.Value?.ToString() ?? "";
    private async Task OnCalledElementChange(ChangeEventArgs e)
    {
        calledElement = e.Value?.ToString() ?? "";
        await JS.InvokeVoidAsync("bpmnEditor.updateElementProperty", Element.Id, "calledElement", calledElement);
    }

    private async Task OnPropagateParentChange(ChangeEventArgs e)
    {
        propagateAllParentVariables = bool.TryParse(e.Value?.ToString(), out var v) && v;
        await JS.InvokeVoidAsync("bpmnEditor.updateElementProperty", Element.Id, "propagateAllParentVariables", propagateAllParentVariables);
    }

    private async Task OnPropagateChildChange(ChangeEventArgs e)
    {
        propagateAllChildVariables = bool.TryParse(e.Value?.ToString(), out var v) && v;
        await JS.InvokeVoidAsync("bpmnEditor.updateElementProperty", Element.Id, "propagateAllChildVariables", propagateAllChildVariables);
    }

    private async Task AddMapping(string type)
    {
        await JS.InvokeVoidAsync("bpmnEditor.addMapping", Element.Id, type);
        var list = type == "input" ? Element.InputMappings : Element.OutputMappings;
        list.Add(new MappingData());
        StateHasChanged();
    }

    private async Task RemoveMapping(string type, int index)
    {
        await JS.InvokeVoidAsync("bpmnEditor.removeMapping", Element.Id, type, index);
        var list = type == "input" ? Element.InputMappings : Element.OutputMappings;
        if (index >= 0 && index < list.Count) list.RemoveAt(index);
        StateHasChanged();
    }

    private async Task OnMappingSourceChange(ChangeEventArgs e, string type, int index)
    {
        var list = type == "input" ? Element.InputMappings : Element.OutputMappings;
        if (index >= 0 && index < list.Count)
        {
            list[index].Source = e.Value?.ToString() ?? "";
            await JS.InvokeVoidAsync("bpmnEditor.updateMapping", Element.Id, type, index, list[index].Source, list[index].Target);
        }
    }

    private async Task OnMappingTargetChange(ChangeEventArgs e, string type, int index)
    {
        var list = type == "input" ? Element.InputMappings : Element.OutputMappings;
        if (index >= 0 && index < list.Count)
        {
            list[index].Target = e.Value?.ToString() ?? "";
            await JS.InvokeVoidAsync("bpmnEditor.updateMapping", Element.Id, type, index, list[index].Source, list[index].Target);
        }
    }

    private string GetTypeLabel() => Element.Type switch
    {
        "bpmn:StartEvent" => "Start Event",
        "bpmn:EndEvent" => "End Event",
        "bpmn:Task" => "Task",
        "bpmn:UserTask" => "User Task",
        "bpmn:ServiceTask" => "Service Task",
        "bpmn:ScriptTask" => "Script Task",
        "bpmn:CallActivity" => "Call Activity",
        "bpmn:ExclusiveGateway" => "Exclusive Gateway",
        "bpmn:ParallelGateway" => "Parallel Gateway",
        "bpmn:SequenceFlow" => "Sequence Flow",
        "bpmn:Process" => "Process",
        "bpmn:IntermediateThrowEvent" => "Intermediate Throw Event",
        "bpmn:IntermediateCatchEvent" => "Intermediate Catch Event",
        _ => Element.Type.Replace("bpmn:", "")
    };

    public class BpmnElementData
    {
        public string Id { get; set; } = "";
        public string Type { get; set; } = "";
        public string Name { get; set; } = "";
        public string ScriptFormat { get; set; } = "";
        public string Script { get; set; } = "";
        public string ConditionExpression { get; set; } = "";
        public string CalledElement { get; set; } = "";
        public bool PropagateAllParentVariables { get; set; } = true;
        public bool PropagateAllChildVariables { get; set; } = true;
        public List<MappingData> InputMappings { get; set; } = [];
        public List<MappingData> OutputMappings { get; set; } = [];
    }

    public class MappingData
    {
        public string Source { get; set; } = "";
        public string Target { get; set; } = "";
    }
}
