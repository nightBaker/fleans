@using Microsoft.FluentUI.AspNetCore.Components
@inject IJSRuntime JS

<div class="properties-panel">
    <div class="properties-panel-header">
        <FluentLabel Typo="Typography.Body" Weight="FontWeight.Bold">@GetTypeLabel()</FluentLabel>
    </div>

    <div class="properties-panel-body">
        <FluentStack Orientation="Orientation.Vertical" Gap="12px">
            @if (!ReadOnly && GetReplaceOptions() is { Count: > 1 } options)
            {
                <div>
                    <FluentLabel Typo="Typography.Body" Weight="FontWeight.Bold">Type</FluentLabel>
                    <FluentSelect TOption="string" Value="@Element.Type" @onchange="OnTypeChange" Style="width: 100%;">
                        @foreach (var opt in options)
                        {
                            <FluentOption TOption="string" Value="@opt.Key" Selected="@(opt.Key == Element.Type)">@opt.Value</FluentOption>
                        }
                    </FluentSelect>
                </div>
            }

            <div>
                <FluentLabel Typo="Typography.Body" Weight="FontWeight.Bold">ID</FluentLabel>
                <FluentTextField Value="@elementId" @oninput="OnIdInput" @onchange="OnIdChange" Disabled="@ReadOnly" Style="width: 100%;" />
            </div>

            <div>
                <FluentLabel Typo="Typography.Body" Weight="FontWeight.Bold">Name</FluentLabel>
                <FluentTextField Value="@name" @oninput="OnNameInput" @onchange="OnNameChange" Disabled="@ReadOnly" Style="width: 100%;" />
            </div>

            @if (Element.Type == "bpmn:ScriptTask")
            {
                <div>
                    <FluentLabel Typo="Typography.Body" Weight="FontWeight.Bold">Script Format</FluentLabel>
                    <FluentTextField Value="@scriptFormat" @oninput="OnScriptFormatInput" @onchange="OnScriptFormatChange"
                                     Disabled="@ReadOnly" Placeholder="e.g. javascript" Style="width: 100%;" />
                </div>

                <div>
                    <FluentLabel Typo="Typography.Body" Weight="FontWeight.Bold">Script</FluentLabel>
                    <FluentTextArea Value="@script" @oninput="OnScriptInput" @onchange="OnScriptChange"
                                    Disabled="@ReadOnly" Rows="8" Resize="TextAreaResize.Vertical" Style="width: 100%;" />
                </div>
            }

            @if (Element.Type == "bpmn:CallActivity")
            {
                <div>
                    <FluentLabel Typo="Typography.Body" Weight="FontWeight.Bold">Called Process Key</FluentLabel>
                    <FluentTextField Value="@calledElement" @oninput="OnCalledElementInput" @onchange="OnCalledElementChange"
                                     Disabled="@ReadOnly" Placeholder="e.g. child-process-1" Style="width: 100%;" />
                </div>

                <div>
                    <FluentCheckbox Value="@propagateAllParentVariables" @onchange="OnPropagateParentChange"
                                    Disabled="@ReadOnly" Label="Propagate all parent variables" />
                </div>

                <div>
                    <FluentCheckbox Value="@propagateAllChildVariables" @onchange="OnPropagateChildChange"
                                    Disabled="@ReadOnly" Label="Propagate all child variables" />
                </div>

                <div>
                    <FluentLabel Typo="Typography.Body" Weight="FontWeight.Bold">Input Mappings</FluentLabel>
                    @for (var i = 0; i < Element.InputMappings.Count; i++)
                    {
                        var index = i;
                        <FluentStack Orientation="Orientation.Horizontal" Gap="4px" Style="align-items: end;">
                            <FluentTextField Value="@Element.InputMappings[index].Source"
                                             @onchange="@(e => OnMappingSourceChange(e, "input", index))"
                                             Disabled="@ReadOnly" Placeholder="Source" Style="flex: 1;" />
                            <FluentTextField Value="@Element.InputMappings[index].Target"
                                             @onchange="@(e => OnMappingTargetChange(e, "input", index))"
                                             Disabled="@ReadOnly" Placeholder="Target" Style="flex: 1;" />
                            @if (!ReadOnly)
                            {
                                <FluentButton Appearance="Appearance.Outline" OnClick="@(() => RemoveMapping("input", index))">Remove</FluentButton>
                            }
                        </FluentStack>
                    }
                    @if (!ReadOnly)
                    {
                        <FluentButton Appearance="Appearance.Outline" OnClick="@(() => AddMapping("input"))">Add Input Mapping</FluentButton>
                    }
                </div>

                <div>
                    <FluentLabel Typo="Typography.Body" Weight="FontWeight.Bold">Output Mappings</FluentLabel>
                    @for (var i = 0; i < Element.OutputMappings.Count; i++)
                    {
                        var index = i;
                        <FluentStack Orientation="Orientation.Horizontal" Gap="4px" Style="align-items: end;">
                            <FluentTextField Value="@Element.OutputMappings[index].Source"
                                             @onchange="@(e => OnMappingSourceChange(e, "output", index))"
                                             Disabled="@ReadOnly" Placeholder="Source" Style="flex: 1;" />
                            <FluentTextField Value="@Element.OutputMappings[index].Target"
                                             @onchange="@(e => OnMappingTargetChange(e, "output", index))"
                                             Disabled="@ReadOnly" Placeholder="Target" Style="flex: 1;" />
                            @if (!ReadOnly)
                            {
                                <FluentButton Appearance="Appearance.Outline" OnClick="@(() => RemoveMapping("output", index))">Remove</FluentButton>
                            }
                        </FluentStack>
                    }
                    @if (!ReadOnly)
                    {
                        <FluentButton Appearance="Appearance.Outline" OnClick="@(() => AddMapping("output"))">Add Output Mapping</FluentButton>
                    }
                </div>
            }

            @if (Element.Type == "bpmn:SequenceFlow")
            {
                <div>
                    <FluentLabel Typo="Typography.Body" Weight="FontWeight.Bold">Condition Expression</FluentLabel>
                    <FluentTextArea Value="@conditionExpression" @oninput="OnConditionInput" @onchange="OnConditionChange"
                                    Disabled="@ReadOnly" Rows="3" Resize="TextAreaResize.Vertical"
                                    Placeholder="e.g. ${amount > 100}" Style="width: 100%;" />
                </div>
            }

            @if (HasTimer)
            {
                <div>
                    <FluentLabel Typo="Typography.Body" Weight="FontWeight.Bold">Timer Type</FluentLabel>
                    <FluentSelect TOption="string" Value="@timerType" @onchange="OnTimerTypeChange"
                                  Disabled="@ReadOnly" Style="width: 100%;">
                        @foreach (var opt in GetTimerTypeOptions())
                        {
                            <FluentOption TOption="string" Value="@opt.Key" Selected="@(timerType == opt.Key)">@opt.Value</FluentOption>
                        }
                    </FluentSelect>
                </div>

                <div>
                    <FluentLabel Typo="Typography.Body" Weight="FontWeight.Bold">Timer Expression</FluentLabel>
                    <FluentTextField Value="@timerExpression" @oninput="OnTimerExpressionInput" @onchange="OnTimerExpressionChange"
                                     Disabled="@ReadOnly" Placeholder="@GetTimerPlaceholder()" Style="width: 100%;" />
                    <FluentLabel Style="color: var(--neutral-foreground-hint); margin-top: 4px; font-size: 12px;">
                        @GetTimerHelpText()
                    </FluentLabel>
                </div>
            }

            @if (HasMessage)
            {
                <div>
                    <FluentLabel Typo="Typography.Body" Weight="FontWeight.Bold">Message Name</FluentLabel>
                    <FluentTextField Value="@messageName" @oninput="OnMessageNameInput" @onchange="OnMessageNameChange"
                                     Disabled="@ReadOnly" Placeholder="e.g. cancelOrder" Style="width: 100%;" />
                </div>

                @if (Element.Type != "bpmn:StartEvent")
                {
                    <div>
                        <FluentLabel Typo="Typography.Body" Weight="FontWeight.Bold">Correlation Key</FluentLabel>
                        <FluentTextField Value="@correlationKey" @oninput="OnCorrelationKeyInput" @onchange="OnCorrelationKeyChange"
                                         Disabled="@ReadOnly" Placeholder="e.g. orderId" Style="width: 100%;" />
                        <FluentLabel Style="color: var(--neutral-foreground-hint); margin-top: 4px; font-size: 12px;">
                            Variable name used to correlate incoming messages to this workflow instance
                        </FluentLabel>
                    </div>
                }
            }

            @if (HasSignal)
            {
                <div>
                    <FluentLabel Typo="Typography.Body" Weight="FontWeight.Bold">Signal Name</FluentLabel>
                    <FluentTextField Value="@signalName" @oninput="OnSignalNameInput" @onchange="OnSignalNameChange"
                                     Disabled="@ReadOnly" Placeholder="e.g. approvalGranted" Style="width: 100%;" />
                </div>
            }
        </FluentStack>
    </div>
</div>

@code {
    [Parameter, EditorRequired] public BpmnElementData Element { get; set; } = default!;
    [Parameter] public bool ReadOnly { get; set; }
    [Parameter] public EventCallback<BpmnElementData> OnElementReplaced { get; set; }

    private string elementId = "";
    private string name = "";
    private string scriptFormat = "";
    private string script = "";
    private string conditionExpression = "";
    private string calledElement = "";
    private bool propagateAllParentVariables = true;
    private bool propagateAllChildVariables = true;
    private string timerType = "";
    private string timerExpression = "";
    private string messageName = "";
    private string correlationKey = "";
    private string signalName = "";

    private static readonly Dictionary<string, string> TaskTypes = new()
    {
        ["bpmn:Task"] = "Task",
        ["bpmn:UserTask"] = "User Task",
        ["bpmn:ServiceTask"] = "Service Task",
        ["bpmn:ScriptTask"] = "Script Task",
        ["bpmn:CallActivity"] = "Call Activity",
    };

    private static readonly Dictionary<string, string> GatewayTypes = new()
    {
        ["bpmn:ExclusiveGateway"] = "Exclusive Gateway",
        ["bpmn:ParallelGateway"] = "Parallel Gateway",
    };

    private static readonly Dictionary<string, string> EventTypes = new()
    {
        ["bpmn:StartEvent"] = "Start Event",
        ["bpmn:EndEvent"] = "End Event",
        ["bpmn:IntermediateThrowEvent"] = "Intermediate Throw Event",
        ["bpmn:IntermediateCatchEvent"] = "Intermediate Catch Event",
    };

    protected override void OnParametersSet()
    {
        elementId = Element.Id;
        name = Element.Name;
        scriptFormat = Element.ScriptFormat;
        script = Element.Script;
        conditionExpression = Element.ConditionExpression;
        calledElement = Element.CalledElement;
        propagateAllParentVariables = Element.PropagateAllParentVariables;
        propagateAllChildVariables = Element.PropagateAllChildVariables;
        timerType = Element.TimerType;
        if (Element.HasTimerDefinition && string.IsNullOrEmpty(timerType))
        {
            timerType = Element.Type == "bpmn:StartEvent" ? "cycle" : "duration";
        }
        timerExpression = Element.TimerExpression;
        messageName = Element.MessageName;
        correlationKey = Element.CorrelationKey;
        signalName = Element.SignalName;
    }

    private Dictionary<string, string>? GetReplaceOptions()
    {
        if (TaskTypes.ContainsKey(Element.Type)) return TaskTypes;
        if (GatewayTypes.ContainsKey(Element.Type)) return GatewayTypes;
        if (EventTypes.ContainsKey(Element.Type)) return EventTypes;
        return null;
    }

    private async Task OnTypeChange(ChangeEventArgs e)
    {
        var newType = e.Value?.ToString();
        if (string.IsNullOrEmpty(newType) || newType == Element.Type) return;

        var result = await JS.InvokeAsync<BpmnElementData>("bpmnEditor.replaceElement", Element.Id, newType);
        if (result != null)
        {
            await OnElementReplaced.InvokeAsync(result);
        }
    }

    private void OnIdInput(ChangeEventArgs e) => elementId = e.Value?.ToString() ?? "";
    private async Task OnIdChange(ChangeEventArgs e)
    {
        var newId = e.Value?.ToString() ?? "";
        if (string.IsNullOrWhiteSpace(newId) || newId == Element.Id) return;

        var result = await JS.InvokeAsync<BpmnElementData>("bpmnEditor.updateElementId", Element.Id, newId);
        if (result != null)
        {
            await OnElementReplaced.InvokeAsync(result);
        }
    }

    private void OnNameInput(ChangeEventArgs e) => name = e.Value?.ToString() ?? "";
    private async Task OnNameChange(ChangeEventArgs e)
    {
        name = e.Value?.ToString() ?? "";
        await JS.InvokeVoidAsync("bpmnEditor.updateElementProperty", Element.Id, "name", name);
    }

    private void OnScriptFormatInput(ChangeEventArgs e) => scriptFormat = e.Value?.ToString() ?? "";
    private async Task OnScriptFormatChange(ChangeEventArgs e)
    {
        scriptFormat = e.Value?.ToString() ?? "";
        await JS.InvokeVoidAsync("bpmnEditor.updateElementProperty", Element.Id, "scriptFormat", scriptFormat);
    }

    private void OnScriptInput(ChangeEventArgs e) => script = e.Value?.ToString() ?? "";
    private async Task OnScriptChange(ChangeEventArgs e)
    {
        script = e.Value?.ToString() ?? "";
        await JS.InvokeVoidAsync("bpmnEditor.updateElementProperty", Element.Id, "script", script);
    }

    private void OnConditionInput(ChangeEventArgs e) => conditionExpression = e.Value?.ToString() ?? "";
    private async Task OnConditionChange(ChangeEventArgs e)
    {
        conditionExpression = e.Value?.ToString() ?? "";
        await JS.InvokeVoidAsync("bpmnEditor.updateElementProperty", Element.Id, "conditionExpression", conditionExpression);
    }

    private void OnCalledElementInput(ChangeEventArgs e) => calledElement = e.Value?.ToString() ?? "";
    private async Task OnCalledElementChange(ChangeEventArgs e)
    {
        calledElement = e.Value?.ToString() ?? "";
        await JS.InvokeVoidAsync("bpmnEditor.updateElementProperty", Element.Id, "calledElement", calledElement);
    }

    private async Task OnPropagateParentChange(ChangeEventArgs e)
    {
        propagateAllParentVariables = bool.TryParse(e.Value?.ToString(), out var v) && v;
        await JS.InvokeVoidAsync("bpmnEditor.updateElementProperty", Element.Id, "propagateAllParentVariables", propagateAllParentVariables);
    }

    private async Task OnPropagateChildChange(ChangeEventArgs e)
    {
        propagateAllChildVariables = bool.TryParse(e.Value?.ToString(), out var v) && v;
        await JS.InvokeVoidAsync("bpmnEditor.updateElementProperty", Element.Id, "propagateAllChildVariables", propagateAllChildVariables);
    }

    private bool HasTimer => Element.HasTimerDefinition;
    private bool HasMessage => Element.HasMessageDefinition;
    private bool HasSignal => Element.HasSignalDefinition;

    private static readonly Dictionary<string, string> TimerTypesAll = new()
    {
        ["duration"] = "Duration",
        ["date"] = "Date",
        ["cycle"] = "Cycle",
    };

    private static readonly Dictionary<string, string> TimerTypesStartEvent = new()
    {
        ["date"] = "Date",
        ["cycle"] = "Cycle",
    };

    private Dictionary<string, string> GetTimerTypeOptions() =>
        Element.Type == "bpmn:StartEvent" ? TimerTypesStartEvent : TimerTypesAll;

    private string GetTimerHelpText() => timerType switch
    {
        "duration" => "ISO 8601 duration, e.g. PT5M, PT1H, P1D",
        "date" => "ISO 8601 date/time, e.g. 2026-03-01T10:00:00Z",
        "cycle" => "Repeating interval, e.g. R3/PT10M, R/PT1H",
        _ => ""
    };

    private string GetTimerPlaceholder() => timerType switch
    {
        "duration" => "e.g. PT5M",
        "date" => "e.g. 2026-03-01T10:00:00Z",
        "cycle" => "e.g. R3/PT10M",
        _ => ""
    };

    private async Task OnTimerTypeChange(ChangeEventArgs e)
    {
        timerType = e.Value?.ToString() ?? "";
        timerExpression = "";
        await JS.InvokeVoidAsync("bpmnEditor.updateTimerDefinition", Element.Id, timerType, timerExpression);
    }

    private void OnTimerExpressionInput(ChangeEventArgs e) => timerExpression = e.Value?.ToString() ?? "";

    private async Task OnTimerExpressionChange(ChangeEventArgs e)
    {
        timerExpression = e.Value?.ToString() ?? "";
        await JS.InvokeVoidAsync("bpmnEditor.updateTimerDefinition", Element.Id, timerType, timerExpression);
    }

    private void OnMessageNameInput(ChangeEventArgs e) => messageName = e.Value?.ToString() ?? "";
    private async Task OnMessageNameChange(ChangeEventArgs e)
    {
        messageName = e.Value?.ToString() ?? "";
        await JS.InvokeVoidAsync("bpmnEditor.updateMessageDefinition", Element.Id, messageName, correlationKey);
    }

    private void OnCorrelationKeyInput(ChangeEventArgs e) => correlationKey = e.Value?.ToString() ?? "";
    private async Task OnCorrelationKeyChange(ChangeEventArgs e)
    {
        correlationKey = e.Value?.ToString() ?? "";
        await JS.InvokeVoidAsync("bpmnEditor.updateMessageDefinition", Element.Id, messageName, correlationKey);
    }

    private void OnSignalNameInput(ChangeEventArgs e) => signalName = e.Value?.ToString() ?? "";
    private async Task OnSignalNameChange(ChangeEventArgs e)
    {
        signalName = e.Value?.ToString() ?? "";
        await JS.InvokeVoidAsync("bpmnEditor.updateSignalDefinition", Element.Id, signalName);
    }

    private async Task AddMapping(string type)
    {
        await JS.InvokeVoidAsync("bpmnEditor.addMapping", Element.Id, type);
        var list = type == "input" ? Element.InputMappings : Element.OutputMappings;
        list.Add(new MappingData());
        StateHasChanged();
    }

    private async Task RemoveMapping(string type, int index)
    {
        await JS.InvokeVoidAsync("bpmnEditor.removeMapping", Element.Id, type, index);
        var list = type == "input" ? Element.InputMappings : Element.OutputMappings;
        if (index >= 0 && index < list.Count) list.RemoveAt(index);
        StateHasChanged();
    }

    private async Task OnMappingSourceChange(ChangeEventArgs e, string type, int index)
    {
        var list = type == "input" ? Element.InputMappings : Element.OutputMappings;
        if (index >= 0 && index < list.Count)
        {
            list[index].Source = e.Value?.ToString() ?? "";
            await JS.InvokeVoidAsync("bpmnEditor.updateMapping", Element.Id, type, index, list[index].Source, list[index].Target);
        }
    }

    private async Task OnMappingTargetChange(ChangeEventArgs e, string type, int index)
    {
        var list = type == "input" ? Element.InputMappings : Element.OutputMappings;
        if (index >= 0 && index < list.Count)
        {
            list[index].Target = e.Value?.ToString() ?? "";
            await JS.InvokeVoidAsync("bpmnEditor.updateMapping", Element.Id, type, index, list[index].Source, list[index].Target);
        }
    }

    private string GetTypeLabel()
    {
        if (HasTimer)
        {
            return Element.Type switch
            {
                "bpmn:StartEvent" => "Timer Start Event",
                "bpmn:IntermediateCatchEvent" => "Timer Intermediate Catch Event",
                "bpmn:BoundaryEvent" => "Boundary Timer Event",
                _ => Element.Type.Replace("bpmn:", "")
            };
        }
        if (HasMessage)
        {
            return Element.Type switch
            {
                "bpmn:IntermediateCatchEvent" => "Message Intermediate Catch Event",
                "bpmn:BoundaryEvent" => "Message Boundary Event",
                _ => Element.Type.Replace("bpmn:", "")
            };
        }
        if (HasSignal)
        {
            return Element.Type switch
            {
                "bpmn:IntermediateCatchEvent" => "Signal Intermediate Catch Event",
                "bpmn:IntermediateThrowEvent" => "Signal Intermediate Throw Event",
                "bpmn:BoundaryEvent" => "Signal Boundary Event",
                _ => Element.Type.Replace("bpmn:", "")
            };
        }
        return Element.Type switch
        {
            "bpmn:StartEvent" => "Start Event",
            "bpmn:EndEvent" => "End Event",
            "bpmn:Task" => "Task",
            "bpmn:UserTask" => "User Task",
            "bpmn:ServiceTask" => "Service Task",
            "bpmn:ScriptTask" => "Script Task",
            "bpmn:CallActivity" => "Call Activity",
            "bpmn:ExclusiveGateway" => "Exclusive Gateway",
            "bpmn:ParallelGateway" => "Parallel Gateway",
            "bpmn:SequenceFlow" => "Sequence Flow",
            "bpmn:Process" => "Process",
            "bpmn:IntermediateThrowEvent" => "Intermediate Throw Event",
            "bpmn:IntermediateCatchEvent" => "Intermediate Catch Event",
            "bpmn:BoundaryEvent" => "Boundary Event",
            _ => Element.Type.Replace("bpmn:", "")
        };
    }

    public class BpmnElementData
    {
        public string Id { get; set; } = "";
        public string Type { get; set; } = "";
        public string Name { get; set; } = "";
        public string ScriptFormat { get; set; } = "";
        public string Script { get; set; } = "";
        public string ConditionExpression { get; set; } = "";
        public string CalledElement { get; set; } = "";
        public bool PropagateAllParentVariables { get; set; } = true;
        public bool PropagateAllChildVariables { get; set; } = true;
        public List<MappingData> InputMappings { get; set; } = [];
        public List<MappingData> OutputMappings { get; set; } = [];
        public string TimerType { get; set; } = "";
        public string TimerExpression { get; set; } = "";
        public bool HasTimerDefinition { get; set; }
        public bool HasMessageDefinition { get; set; }
        public string MessageName { get; set; } = "";
        public string CorrelationKey { get; set; } = "";
        public bool HasSignalDefinition { get; set; }
        public string SignalName { get; set; } = "";
    }

    public class MappingData
    {
        public string Source { get; set; } = "";
        public string Target { get; set; } = "";
    }
}
